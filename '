#include <iostream>
#include <stdint.h>
#include "hardware.h"
#include "display.h"
#include "context.h"

namespace hardware {

	void init()
	{
		// Inititalize hardware and set up hardware state
		std::shared_ptr <context::EmuContext_t> emuCtx = ctx->mEmuContext;

		std::shared_ptr<CPU> cpu(new CPU);
		std::shared_ptr<Memory> memory(new Memory);

		emuCtx->mCpu = cpu;
		emuCtx->mMemory = memory;

		emuCtx->mStatus = context::RUNNING;
		emuCtx->mPC = ROM_ENTRY;

		memory->loadFont();

		cpu->cycle();
	}

	void CPU::cycle()
	{
		std::shared_ptr <context::EmuContext_t> emuCtx = ctx->mEmuContext;

		while (emuCtx->mStatus != context::QUIT)
		{
			emuCtx->mCpu->pollInput();

			if (emuCtx->mStatus == context::PAUSED) continue;

			display::updateDisplay();
		}
	}

	void CPU::pollInput()
	{
		std::shared_ptr <context::EmuContext_t> emuCtx = ctx->mEmuContext;

		SDL_Event event;

		while (SDL_PollEvent(&event))
		{
			switch (event.type) {
				case SDL_QUIT:
					emuCtx->mStatus = context::QUIT;

					return;
				
				case SDL_KEYDOWN:
					switch (event.key.keysym.sym) {
						case SDLK_ESCAPE:
							emuCtx->mStatus = context::QUIT;
						case SDLK_SPACE:
							if (emuCtx->mStatus == context::RUNNING)
							{
								emuCtx->mStatus = context::PAUSED;
								DEBUG_LOG("Emulator Paused.");
							}
							else
							{
								emuCtx->mStatus = context::RUNNING;
								DEBUG_LOG("Emulator Resuming.");
							}

							return;
						default:
							break;
					}
					break;

			case SDL_KEYUP:
				break;
			}
		}
	}

	void Memory::loadFont()
	{
		std::shared_ptr <context::EmuContext_t> emuCtx = ctx->mEmuContext;

		const uint8_t font[] = {
			0xF0, 0x90, 0x90, 0x90, 0xF0,   // 0   
			0x20, 0x60, 0x20, 0x20, 0x70,   // 1  
			0xF0, 0x10, 0xF0, 0x80, 0xF0,   // 2 
			0xF0, 0x10, 0xF0, 0x10, 0xF0,   // 3
			0x90, 0x90, 0xF0, 0x10, 0x10,   // 4    
			0xF0, 0x80, 0xF0, 0x10, 0xF0,   // 5
			0xF0, 0x80, 0xF0, 0x90, 0xF0,   // 6
			0xF0, 0x10, 0x20, 0x40, 0x40,   // 7
			0xF0, 0x90, 0xF0, 0x90, 0xF0,   // 8
			0xF0, 0x90, 0xF0, 0x10, 0xF0,   // 9
			0xF0, 0x90, 0xF0, 0x90, 0x90,   // A
			0xE0, 0x90, 0xE0, 0x90, 0xE0,   // B
			0xF0, 0x80, 0x80, 0x80, 0xF0,   // C
			0xE0, 0x90, 0x90, 0x90, 0xE0,   // D
			0xF0, 0x80, 0xF0, 0x80, 0xF0,   // E
			0xF0, 0x80, 0xF0, 0x80, 0x80,   // F
		};

		memcpy(&emuCtx->mRam, font, sizeof(font));
	}

	void Memory::loadRom(const char* pRomFileName)
	{
		std::shared_ptr <context::EmuContext_t> emuCtx = ctx->mEmuContext;

		FILE* pRom;
		FILE** pRomFile = &pRom;

		size_t romSize;
		size_t maxRomSize = sizeof(emuCtx->mRam - ROM_ENTRY);
		
		fopen_s(pRomFile, pRomFileName, "rb");

		if (!pRom)
		{
			DEBUG_LOG("Failed to load ROM.");
			exit(1);
		}

		fseek(pRom, 0, SEEK_END);
		romSize = ftell(pRom);
		rewind(pRom);

		if (romSize > maxRomSize)
		{
			DEBUG_LOG("ROM size is too large.");
			exit(1);
		}

		if (fread(&emuCtx->mRam[ROM_ENTRY], romSize, 1, pRom))
		{
			DEBUG_LOG("Could not read ROM file into memory");
			exit(1);
		}

		fclose(pRom);
	}
}
